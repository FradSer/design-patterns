# 工厂模式

工厂模式根据抽象程度的不同分为三种：简单工厂模式（也叫静态工厂模式）、工厂方法模式、抽象工厂模式。

## 简单工厂模式

可以根据参数的不同返回不同类的实例。

简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

```swift
protocol Shape {
    func draw()
}

class Rectangle : Shape {
    func draw() {
        print("Draw Rectangle")
    }
}

class Square: Shape {
    func draw() {
        print("Draw Square")
    }
}

class Circle: Square {
    override func draw() {
        print("Draw Circle")
    }
}

class ShapeFactory {
    func getShape(shapeType: String) -> Shape? {
        if shapeType == "CIRCLE" {
            return Circle()
        } else if shapeType == "RECTANGLE" {
            return Rectangle()
        } else if  shapeType == "SQUARE" {
            return Square()
        }
        return nil
    }
}

let facctory = ShapeFactory()
let circle = facctory.getShape(shapeType: "CIRCLE")
circle?.draw()
```

## 工厂方法模式

工厂方法模式是简单工厂的进一步深化，在工厂方法模式中，不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。


```dart

protocol Reader {
    func read()
}

class JPGReader : Reader {
    func read() {
        print("read jpg")
    }
}


class PNGReader: Reader {
    func read() {
        print("read png")
    }
}

class GIFReader: Reader {
    func read() {
        print("read gif")
    }
}

protocol ReaderFactory {
    func getReader() -> Reader
}

class JPGReaderFactory : ReaderFactory {
    func getReader() -> Reader {
        JPGReader()
    }
}

class PNGReaderFactory: ReaderFactory {
    func getReader() -> Reader {
        PNGReader()
    }
}

class GIFReaderFactory: ReaderFactory {
    func getReader() -> Reader {
        GIFReader()
    }
}

var factory: ReaderFactory = GIFReaderFactory()
var reader: Reader = factory.getReader()
reader.read() // read gif

factory = PNGReaderFactory()
reader = factory.getReader()
reader.read() // read png

factory = JPGReaderFactory()
reader = factory.getReader()
reader.read() // read jpg
```

与简单工厂对比，最根本的区别在于，简单工厂只有一个统一的工厂类，而工厂方法是针对每个要创建的对象都会提供一个工厂类，这些工厂类都实现了一个工厂基类。

那么创建这么多工厂类有什么好处？

1. 不需要知道它所创建的对象的类。例子中我们不知道每个图片加载器具体叫什么名，只知道创建它的工厂名就完成了创建过程。
2. 客户端可以通过子类来指定创建对应的对象。


## 抽象工厂模式

为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。

```swift

class BenzCar {
    var name: String
    
    init(name: String) {
        self.name = name
    }
    
    func drive() {}
}

class BenzSportCar : BenzCar {
    override func drive() {
        print("\(name) :: BenzSportCart")
    }
}

class BenzBusinessCar : BenzCar {
    override func drive() {
        print("\(name) :: BenzBusinessCar")
    }
}


class BmwCar {
    var name: String
    
    init(name: String) {
        self.name = name
    }
    
    func drive() {}
}

class BmwSportCar : BmwCar {
    override func drive() {
        print("\(name) :: BmwCSportCart")
    }
}

class BmwBusinessCar : BmwCar {
    override func drive() {
        print("\(name) :: BmwBusinessCar")
    }
}

class AudiCar {
    var name: String
    
    init(name: String) {
        self.name = name
    }
    
    func drive() {}
}

class AudiSportCar : AudiCar {
    override func drive() {
        print("\(name) :: AudiCSportCart")
    }
}

class AudiBusinessCar : AudiCar {
    override func drive() {
        print("\(name) :: AudiBusinessCar")
    }
}


protocol Driver {
    func createBenzCar(car: String) -> BenzCar
    func createBmwCar(car: String) -> BmwCar
    func createAudiCar(car: String) -> AudiCar
}

class SupportDriver : Driver {
    
    func createBenzCar(car: String) -> BenzCar {
        BenzSportCar.init(name: car)
    }
    
    func createBmwCar(car: String) -> BmwCar {
        BmwSportCar.init(name: car)
    }
    
    func createAudiCar(car: String) -> AudiCar {
        AudiSportCar.init(name: car)
    }
}


class BusinessDriver: Driver {
    func createBenzCar(car: String) -> BenzCar {
        BenzBusinessCar.init(name: car)
    }
    
    func createBmwCar(car: String) -> BmwCar {
        BmwBusinessCar.init(name: car)
    }
    
    func createAudiCar(car: String) -> AudiCar {
        AudiBusinessCar.init(name: car)
    }
}

let driver = BusinessDriver()
let car = driver.createAudiCar(car: "BusinessDriver")
car.drive()
```



## 三者对比

|  |简单工厂| 工厂方法| 抽象工厂|
| -- | --    |   -- |  --|
|特点|  使用静态方法通过接受参数的不同来返回不同的实例| 针对每一种产品提供一个工厂类 | 针对产品族 | 
| 扩展方式 | 在不修改代码的前提下无法扩展 | 在同一级别中可以任意扩展 | 应对产品族的概念，可以增加新的产品线，但无法增加新的产品 |
| 优点 | 在于工厂类中包含了必要的逻辑，更具客户需要的条件动态实例化相关的类，对客户端来说，去掉了与具体产品的依赖 | 创建对象的接口，让子类去决定具体的实例化的对象，把简单的内部逻辑判断移到了客户端代码。工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。| 分离了具体的类，抽象工厂模式帮助你控制一个应用创建的对象的类，客户通过他们的抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。它使得易于交换产品系列。|
| 缺点 | 工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，当增加新的产品时，会违反开发-封闭原则 | 不易于维护，假如某个具体的产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同事需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦 | 抽象工厂模式在于难于应对“新对象”的需求变动，难以支持新种类产品，难以扩展抽象工厂以生产新种类产品 |
